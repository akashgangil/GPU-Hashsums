Build Instructions:
make clean
make

Generate the random message file input.in:
python randomMessage.py 64

To run: ./crc

Sample output:

gangil@gangil:src$ ./crc
Timer: gettimeofday
Timer resolution: ~ 1 us (?)
crcSlow() 0x46570A0D    Time: 8.7534
Parallel() 0x46570A0D   Time:  0.037578 
crcFast() 0x46570A0D    Time: 4.57043
crc_intel() 0x46570A0D    Time: 0.091564

By default it computes the checksum for CRC32C-SCSI

Here,
crcSlow() is the bit-by-bit method
crcFast() is the byte-by-byte(Table Lookup) method
Parallel() is the openmp method with the intel's crc32 instruction.
crc_intel() is calculates crc just with intel's crc method.

For the Java program,
To compile: javac CRC32.java
To run: java CRC32

For the GPU program,
qsub crc.pbs


CRC32.java      : Contains the java CRC32 implementation

randomMessage.py: Takes in numbers of MB's as input and generates a message. 

crc_intel.c     : Uses Intel Intrinsic Intruction _mm_crc32_u32/_mm_crc32_u8 to calculate the crc

parallel_crc.c  : Contains the zlib's crc32_combine method to combine checksums to two data blocks

crc_gpu.cu      : CRC32 Cuda Implementation

input.in        : Generated by the randomMessage.py script. Contains the random data message.

crc.pbs			: pbs file to execute on the jinx cluster.

zlibCRC32.c		: zlib crc benchmark

-------------------------------------------
CRC32C MPEG and CRC32C SCSI:

By default the code runs for CRC32C-SCSI polynomial. If you want to run it for CRC32-C MPEG,
you would have to recompile the code with these couple of changes:

1. In crc.h: line 9 do #define CRC_MPEG instead of #define CRC_SCSI

2. In parallel_crc.c, uncomment line 39 and comment out line 42.

You might see that in this case the crc_intel's answer differs from the rest, this is because it always uses CRC_32C-SCSI
for checksum computation.



