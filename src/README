Build Instructions:
`make clean`
`make`

Generate the random message file input.in:
`python randomMessage.py 64`

To run: `./crc`

Sample output:

gangil@gangil:src$ ./crc
Timer: gettimeofday
Timer resolution: ~ 1 us (?)
crcSlow() 0x46570A0D    Time: 8.7534
Parallel() 0x46570A0D   Time:  0.037578 
crcFast() 0x46570A0D    Time: 4.57043
crc_intel() 0x46570A0D    Time: 0.091564

By default it computes the checksum for CRC32C-SCSI

Here,
crcSlow() is the bit-by-bit method
crcFast() is the byte-by-byte(Table Lookup) method
Parallel() is the openmp method with the intel's crc32 instruction.
crc_intel() is calculates crc just with intel's crc method.

For the Java program,
To compile: `javac CRC32.java`
To run: `java CRC32`

For the GPU program,
`qsub crc.pbs`


CRC32.java      : Contains the java CRC32 implementation

randomMessage.py: Takes in numbers of MB's as input and generates a message. 

crc\_intel.c     : Uses Intel Intrinsic Intruction \_mm\_crc32\_u32/\_mm\_crc32\_u8 to calculate the crc

parallel\_crc.c  : Contains the zlib's crc32\_combine method to combine checksums to two data blocks

crc\_gpu.cu      : CRC32 Cuda Implementation

input.in        : Generated by the randomMessage.py script. Contains the random data message.

